{{- define "parameterList" -}}
{{ range $i, $param := . }}{{ if $i }}, {{ end }}{{ $param.Name }} {{ $param.Type }}{{ end }}
{{- end -}}

{{- define "resultList" -}}
{{ range $i, $returnParam := . }}{{ if $i }}, {{ end }}{{ if $returnParam.Name }}{{ $returnParam.Name }}{{ else }}r{{ $i }}{{ end }} {{ $returnParam.Type }}{{ end }}
{{- end -}}

{{- define "resultTypeList" -}}
{{ range $i, $returnParam := . }}{{ if $i }}, {{ end }}{{ $returnParam.Type }}{{ end }}
{{- end -}}

{{- define "observationCallback" -}}
func({{ template "parameterList" .Parameters }}) ({{ template "resultTypeList" .Returns }})
{{- end -}}

{{- define "matcherTypeParams" -}}
{{ range $i, $param := . }}{{ if ne $i 0 }}, {{ end }}P{{ $i }} {{ $param.Type }} | kelpie.Matcher[{{ $param.Type }}]{{ end }}
{{- end -}}

{{- define "matcherParams" -}}
{{ range $i, $param := . }}{{ if ne $i 0 }}, {{ end }}{{ $param.Name }} P{{ $i }}{{ end }}
{{- end -}}

// Code generated by Kelpie. DO NOT EDIT.
package {{ .PackageName }}

import "github.com/adamconnelly/kelpie"

type Mock struct {
	expectations []Expectation
}

{{- range $method := .Methods }}

func (m *Mock) {{ $method.Name }}({{ template "parameterList" $method.Parameters }}) ({{ template "resultList" $method.Returns }}) {
    for _, expectation := range m.expectations {
		if expectation.method == "{{ $method.Name }}" {
			info := expectation.invocationDetails.({{ $method.Name }}InvocationDetails)
            if {{ range $i, $param := $method.Parameters }}{{ if $i }} && {{ end }}info.{{ $param.Name }}.IsMatch({{ $param.Name }}){{ end }} {
				if info.observe != nil {
					return info.observe({{ range $i, $param := $method.Parameters }}{{ if ne $i 0 }}, {{ end }}{{ $param.Name }}{{ end }})
				}

				if info.panicArg != nil {
					panic(info.panicArg)
				}

                return {{ range $i, $r := $method.Returns }}{{ if ne $i 0 }}, {{ end }}info.{{ if $r.Name }}{{ $r.Name }}{{ else }}result{{ $i }}{{ end }}{{ end }}
			}
		}
	}

    return
}
{{- end }}

type Expectation struct {
	method            string
	invocationDetails interface{}
}

func (m *Mock) Reset() {
	m.expectations = nil
}

func (m *Mock) Setup(expectation Expectation) {
	m.expectations = append([]Expectation{expectation}, m.expectations...)
}

{{ range $method := .Methods }}
type {{ $method.Name }}InvocationDetails struct {
    {{- range $param := $method.Parameters }}
    {{ $param.Name }} kelpie.Matcher[{{ $param.Type }}]
    {{- end }}
    {{- range $i, $r := $method.Returns }}
    {{ if $r.Name }}{{ $r.Name }}{{ else }}result{{ $i }}{{ end }} {{ $r.Type }}
    {{- end }}
	panicArg any
	observe {{ template "observationCallback" $method }}
}

func {{ $method.Name }}[{{ template "matcherTypeParams" $method.Parameters }}]({{ template "matcherParams" $method.Parameters }}) {{ $method.Name }}InvocationDetails {
{{- /* TODO: maybe wrap the parameters in an anonymous struct to avoid name collisions? */ -}}
{{- range $i, $param := $method.Parameters }}
    var p{{ $i }} kelpie.Matcher[{{ $param.Type }}]
    if matcher, ok := any({{ $param.Name }}).(kelpie.Matcher[{{ $param.Type }}]); ok {
        p{{ $i }} = matcher
    } else {
        p{{ $i }} = kelpie.ExactMatch(any({{ $param.Name }}).({{ $param.Type }}))
    }
{{ end }}
    return {{ $method.Name }}InvocationDetails{
        {{- range $i, $param := $method.Parameters }}
        {{ $param.Name }}: p{{ $i }},
        {{- end }}
    }
}

func (a {{ $method.Name }}InvocationDetails) Return({{ template "resultList" $method.Returns }}) Expectation {
{{- range $i, $r := $method.Returns }}
    a.{{ if $r.Name }}{{ $r.Name }}{{ else }}result{{ $i }}{{ end }} = {{ if $r.Name }}{{ $r.Name }}{{ else }}r{{ $i }}{{ end }}
{{- end }}

	return Expectation{
		method:            "{{ $method.Name }}",
		invocationDetails: a,
	}
}

func (a {{ $method.Name }}InvocationDetails) Panic(arg any) Expectation {
	a.panicArg = arg

	return Expectation{
		method:            "{{ $method.Name }}",
		invocationDetails: a,
	}
}

func (a {{ $method.Name }}InvocationDetails) When(callback {{ template "observationCallback" $method }}) Expectation {
	a.observe = callback

	return Expectation{
		method:            "{{ $method.Name }}",
		invocationDetails: a,
	}
}
{{- end }}
