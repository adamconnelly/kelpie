// Code generated by Kelpie. DO NOT EDIT.
package emailservice

import "github.com/adamconnelly/kelpie"

type Mock struct {
	expectations []Expectation
}

func (m *Mock) Send(sender string, recipient string, body string) (cost float64, err error) {
    for _, expectation := range m.expectations {
		if expectation.method == "Send" {
			info := expectation.invocationDetails.(SendInvocationDetails)
            if info.sender.IsMatch(sender) && info.recipient.IsMatch(recipient) && info.body.IsMatch(body) {
				if info.observe != nil {
					return info.observe(sender, recipient, body)
				}

				if info.panicArg != nil {
					panic(info.panicArg)
				}

                return info.cost, info.err
			}
		}
	}

    return
}

type Expectation struct {
	method            string
	invocationDetails interface{}
}

func (m *Mock) Reset() {
	m.expectations = nil
}

func (m *Mock) Setup(expectation Expectation) {
	m.expectations = append([]Expectation{expectation}, m.expectations...)
}


type SendInvocationDetails struct {
    sender kelpie.Matcher[string]
    recipient kelpie.Matcher[string]
    body kelpie.Matcher[string]
    cost float64
    err error
	panicArg any
	observe func(sender string, recipient string, body string) (float64, error)
}

func Send[P0 string | kelpie.Matcher[string], P1 string | kelpie.Matcher[string], P2 string | kelpie.Matcher[string]](sender P0, recipient P1, body P2) SendInvocationDetails {
    var p0 kelpie.Matcher[string]
    if matcher, ok := any(sender).(kelpie.Matcher[string]); ok {
        p0 = matcher
    } else {
        p0 = kelpie.ExactMatch(any(sender).(string))
    }

    var p1 kelpie.Matcher[string]
    if matcher, ok := any(recipient).(kelpie.Matcher[string]); ok {
        p1 = matcher
    } else {
        p1 = kelpie.ExactMatch(any(recipient).(string))
    }

    var p2 kelpie.Matcher[string]
    if matcher, ok := any(body).(kelpie.Matcher[string]); ok {
        p2 = matcher
    } else {
        p2 = kelpie.ExactMatch(any(body).(string))
    }

    return SendInvocationDetails{
        sender: p0,
        recipient: p1,
        body: p2,
    }
}

func (a SendInvocationDetails) Return(cost float64, err error) Expectation {
    a.cost = cost
    a.err = err

	return Expectation{
		method:            "Send",
		invocationDetails: a,
	}
}

func (a SendInvocationDetails) Panic(arg any) Expectation {
	a.panicArg = arg

	return Expectation{
		method:            "Send",
		invocationDetails: a,
	}
}

func (a SendInvocationDetails) When(callback func(sender string, recipient string, body string) (float64, error)) Expectation {
	a.observe = callback

	return Expectation{
		method:            "Send",
		invocationDetails: a,
	}
}
