// Code generated by Kelpie. DO NOT EDIT.
package maths

import "github.com/adamconnelly/kelpie"

type Mock struct {
	expectations []Expectation
}

func (m *Mock) Add(a int, b int) (r0 int) {
    for _, expectation := range m.expectations {
		if expectation.method == "Add" {
			info := expectation.invocationDetails.(AddInvocationDetails)
            if info.a.IsMatch(a) && info.b.IsMatch(b) {
				if info.observe != nil {
					return info.observe(a, b)
				}

				if info.panicArg != nil {
					panic(info.panicArg)
				}

                return info.result0
			}
		}
	}

    return
}

func (m *Mock) ParseInt(input string) (r0 int, r1 error) {
    for _, expectation := range m.expectations {
		if expectation.method == "ParseInt" {
			info := expectation.invocationDetails.(ParseIntInvocationDetails)
            if info.input.IsMatch(input) {
				if info.observe != nil {
					return info.observe(input)
				}

				if info.panicArg != nil {
					panic(info.panicArg)
				}

                return info.result0, info.result1
			}
		}
	}

    return
}

type Expectation struct {
	method            string
	invocationDetails interface{}
}

func (m *Mock) Reset() {
	m.expectations = nil
}

func (m *Mock) Setup(expectation Expectation) {
	m.expectations = append([]Expectation{expectation}, m.expectations...)
}


type AddInvocationDetails struct {
    a kelpie.Matcher[int]
    b kelpie.Matcher[int]
    result0 int
	panicArg any
	observe func(a int, b int) (int)
}

func Add[P0 int | kelpie.Matcher[int], P1 int | kelpie.Matcher[int]](a P0, b P1) AddInvocationDetails {
    var p0 kelpie.Matcher[int]
    if matcher, ok := any(a).(kelpie.Matcher[int]); ok {
        p0 = matcher
    } else {
        p0 = kelpie.ExactMatch(any(a).(int))
    }

    var p1 kelpie.Matcher[int]
    if matcher, ok := any(b).(kelpie.Matcher[int]); ok {
        p1 = matcher
    } else {
        p1 = kelpie.ExactMatch(any(b).(int))
    }

    return AddInvocationDetails{
        a: p0,
        b: p1,
    }
}

func (a AddInvocationDetails) Return(r0 int) Expectation {
    a.result0 = r0

	return Expectation{
		method:            "Add",
		invocationDetails: a,
	}
}

func (a AddInvocationDetails) Panic(arg any) Expectation {
	a.panicArg = arg

	return Expectation{
		method:            "Add",
		invocationDetails: a,
	}
}

func (a AddInvocationDetails) When(callback func(a int, b int) (int)) Expectation {
	a.observe = callback

	return Expectation{
		method:            "Add",
		invocationDetails: a,
	}
}
type ParseIntInvocationDetails struct {
    input kelpie.Matcher[string]
    result0 int
    result1 error
	panicArg any
	observe func(input string) (int, error)
}

func ParseInt[P0 string | kelpie.Matcher[string]](input P0) ParseIntInvocationDetails {
    var p0 kelpie.Matcher[string]
    if matcher, ok := any(input).(kelpie.Matcher[string]); ok {
        p0 = matcher
    } else {
        p0 = kelpie.ExactMatch(any(input).(string))
    }

    return ParseIntInvocationDetails{
        input: p0,
    }
}

func (a ParseIntInvocationDetails) Return(r0 int, r1 error) Expectation {
    a.result0 = r0

    a.result1 = r1

	return Expectation{
		method:            "ParseInt",
		invocationDetails: a,
	}
}

func (a ParseIntInvocationDetails) Panic(arg any) Expectation {
	a.panicArg = arg

	return Expectation{
		method:            "ParseInt",
		invocationDetails: a,
	}
}

func (a ParseIntInvocationDetails) When(callback func(input string) (int, error)) Expectation {
	a.observe = callback

	return Expectation{
		method:            "ParseInt",
		invocationDetails: a,
	}
}
