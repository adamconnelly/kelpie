// Code generated by Kelpie. DO NOT EDIT.
package userrepository

import (
	"github.com/adamconnelly/kelpie"
	"github.com/adamconnelly/kelpie/mocking"
	"github.com/adamconnelly/kelpie/examples/users"
)

type Mock struct {
	mocking.Mock
	instance Instance
}

func NewMock() *Mock {
	mock := Mock{
		instance: Instance{},
	}
	mock.instance.mock = &mock

	return &mock
}

type Instance struct {
	mock *Mock
}

func (m *Instance) FindUserByUsername(username string) (r0 *users.User, r1 error) {
	expectation := m.mock.Call("FindUserByUsername", username)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(username string) (*users.User, error))
			return observe(username)
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].(*users.User)
		}

		if expectation.Returns[1] != nil {
			r1 = expectation.Returns[1].(error)
		}
	}

	return
}

func (m *Instance) GetAllUsersOfType(t users.UserType) (r0 []users.User, r1 error) {
	expectation := m.mock.Call("GetAllUsersOfType", t)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(t users.UserType) ([]users.User, error))
			return observe(t)
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].([]users.User)
		}

		if expectation.Returns[1] != nil {
			r1 = expectation.Returns[1].(error)
		}
	}

	return
}

func (m *Mock) Instance() *Instance {
	return &m.instance
}

type FindUserByUsernameMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *FindUserByUsernameMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

func FindUserByUsername[P0 string | mocking.Matcher[string]](username P0) *FindUserByUsernameMethodMatcher {
	result := FindUserByUsernameMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "FindUserByUsername",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 1),
		},
	}

	if matcher, ok := any(username).(mocking.Matcher[string]); ok {
		result.matcher.ArgumentMatchers[0] = matcher
	} else {
		result.matcher.ArgumentMatchers[0] = kelpie.ExactMatch(any(username).(string))
	}

	return &result
}

type FindUserByUsernameTimes struct {
	matcher *FindUserByUsernameMethodMatcher
}

// Times allows you to restrict the number of times a particular expectation can be matched.
func (m *FindUserByUsernameMethodMatcher) Times(times uint) *FindUserByUsernameTimes {
	m.matcher.Times = &times

	return &FindUserByUsernameTimes{
		matcher: m,
	}
}

// Once specifies that the expectation will only match once.
func (m *FindUserByUsernameMethodMatcher) Once() *FindUserByUsernameTimes {
	return m.Times(1)
}

// Never specifies that the method has not been called. This is mainly useful for verification
// rather than mocking.
func (m *FindUserByUsernameMethodMatcher) Never() *FindUserByUsernameTimes {
	return m.Times(0)
}

// Return returns the specified results when the method is called.
func (t *FindUserByUsernameTimes) Return(r0 *users.User, r1 error) *FindUserByUsernameAction {
	return &FindUserByUsernameAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			Returns:       []any{r0, r1},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (t *FindUserByUsernameTimes) Panic(arg any) *FindUserByUsernameAction {
	return &FindUserByUsernameAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (t *FindUserByUsernameTimes) When(observe func(username string) (*users.User, error)) *FindUserByUsernameAction {
	return &FindUserByUsernameAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			ObserveFn:     observe,
		},
	}
}

func (t *FindUserByUsernameTimes) CreateMethodMatcher() *mocking.MethodMatcher {
	return &t.matcher.matcher
}

// Return returns the specified results when the method is called.
func (m *FindUserByUsernameMethodMatcher) Return(r0 *users.User, r1 error) *FindUserByUsernameAction {
	return &FindUserByUsernameAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			Returns:       []any{r0, r1},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (m *FindUserByUsernameMethodMatcher) Panic(arg any) *FindUserByUsernameAction {
	return &FindUserByUsernameAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (m *FindUserByUsernameMethodMatcher) When(observe func(username string) (*users.User, error)) *FindUserByUsernameAction {
	return &FindUserByUsernameAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			ObserveFn:     observe,
		},
	}
}

type FindUserByUsernameAction struct {
	expectation mocking.Expectation
}

func (a *FindUserByUsernameAction) CreateExpectation() *mocking.Expectation {
	return &a.expectation
}

type GetAllUsersOfTypeMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *GetAllUsersOfTypeMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

func GetAllUsersOfType[P0 users.UserType | mocking.Matcher[users.UserType]](t P0) *GetAllUsersOfTypeMethodMatcher {
	result := GetAllUsersOfTypeMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "GetAllUsersOfType",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 1),
		},
	}

	if matcher, ok := any(t).(mocking.Matcher[users.UserType]); ok {
		result.matcher.ArgumentMatchers[0] = matcher
	} else {
		result.matcher.ArgumentMatchers[0] = kelpie.ExactMatch(any(t).(users.UserType))
	}

	return &result
}

type GetAllUsersOfTypeTimes struct {
	matcher *GetAllUsersOfTypeMethodMatcher
}

// Times allows you to restrict the number of times a particular expectation can be matched.
func (m *GetAllUsersOfTypeMethodMatcher) Times(times uint) *GetAllUsersOfTypeTimes {
	m.matcher.Times = &times

	return &GetAllUsersOfTypeTimes{
		matcher: m,
	}
}

// Once specifies that the expectation will only match once.
func (m *GetAllUsersOfTypeMethodMatcher) Once() *GetAllUsersOfTypeTimes {
	return m.Times(1)
}

// Never specifies that the method has not been called. This is mainly useful for verification
// rather than mocking.
func (m *GetAllUsersOfTypeMethodMatcher) Never() *GetAllUsersOfTypeTimes {
	return m.Times(0)
}

// Return returns the specified results when the method is called.
func (t *GetAllUsersOfTypeTimes) Return(r0 []users.User, r1 error) *GetAllUsersOfTypeAction {
	return &GetAllUsersOfTypeAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			Returns:       []any{r0, r1},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (t *GetAllUsersOfTypeTimes) Panic(arg any) *GetAllUsersOfTypeAction {
	return &GetAllUsersOfTypeAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (t *GetAllUsersOfTypeTimes) When(observe func(t users.UserType) ([]users.User, error)) *GetAllUsersOfTypeAction {
	return &GetAllUsersOfTypeAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			ObserveFn:     observe,
		},
	}
}

func (t *GetAllUsersOfTypeTimes) CreateMethodMatcher() *mocking.MethodMatcher {
	return &t.matcher.matcher
}

// Return returns the specified results when the method is called.
func (m *GetAllUsersOfTypeMethodMatcher) Return(r0 []users.User, r1 error) *GetAllUsersOfTypeAction {
	return &GetAllUsersOfTypeAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			Returns:       []any{r0, r1},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (m *GetAllUsersOfTypeMethodMatcher) Panic(arg any) *GetAllUsersOfTypeAction {
	return &GetAllUsersOfTypeAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (m *GetAllUsersOfTypeMethodMatcher) When(observe func(t users.UserType) ([]users.User, error)) *GetAllUsersOfTypeAction {
	return &GetAllUsersOfTypeAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			ObserveFn:     observe,
		},
	}
}

type GetAllUsersOfTypeAction struct {
	expectation mocking.Expectation
}

func (a *GetAllUsersOfTypeAction) CreateExpectation() *mocking.Expectation {
	return &a.expectation
}
