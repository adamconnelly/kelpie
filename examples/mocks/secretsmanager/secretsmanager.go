// Code generated by Kelpie. DO NOT EDIT.
package secretsmanager

import (
	"github.com/adamconnelly/kelpie"
	"github.com/adamconnelly/kelpie/mocking"

	"context"
	"github.com/adamconnelly/kelpie/examples/secretsmanager"
)

type Mock struct {
	mocking.Mock
	instance instance
}

func NewMock() *Mock {
	mock := Mock{
		instance: instance{},
	}
	mock.instance.mock = &mock

	return &mock
}

type instance struct {
	mock *Mock
}

func (m *instance) GetSecret(ctx context.Context, name string, opts ...func(*secretsmanager.GetSecretOptions)) (r0 *secretsmanager.GetSecretResult, r1 error) {
	expectation := m.mock.Call("GetSecret", ctx, name, opts)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(ctx context.Context, name string, opts ...func(*secretsmanager.GetSecretOptions)) (*secretsmanager.GetSecretResult, error))
			return observe(ctx, name, opts...)
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].(*secretsmanager.GetSecretResult)
		}

		if expectation.Returns[1] != nil {
			r1 = expectation.Returns[1].(error)
		}
	}

	return
}

func (m *Mock) Instance() *instance {
	return &m.instance
}

type getSecretMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *getSecretMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

func GetSecret[P0 mocking.Matcher[context.Context], P1 string | mocking.Matcher[string], P2 func(*secretsmanager.GetSecretOptions) | mocking.Matcher[func(*secretsmanager.GetSecretOptions)]](ctx P0, name P1, opts ...P2) *getSecretMethodMatcher {
	result := getSecretMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "GetSecret",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 3),
		},
	}

	if matcher, ok := any(ctx).(mocking.Matcher[context.Context]); ok {
		result.matcher.ArgumentMatchers[0] = matcher
	} else {
		result.matcher.ArgumentMatchers[0] = kelpie.ExactMatch(any(ctx).(context.Context))
	}

	if matcher, ok := any(name).(mocking.Matcher[string]); ok {
		result.matcher.ArgumentMatchers[1] = matcher
	} else {
		result.matcher.ArgumentMatchers[1] = kelpie.ExactMatch(any(name).(string))
	}

	var matchers []mocking.ArgumentMatcher
	for _, arg := range opts {
		if matcher, ok := any(arg).(mocking.ArgumentMatcher); ok {
			matchers = append(matchers, matcher)
		} else {
			matchers = append(matchers, kelpie.ExactMatch(any(arg).(func(*secretsmanager.GetSecretOptions))))
		}
	}

	result.matcher.ArgumentMatchers[2] = mocking.Variadic(matchers)

	return &result
}

type getSecretTimes struct {
	matcher *getSecretMethodMatcher
}

// Times allows you to restrict the number of times a particular expectation can be matched.
func (m *getSecretMethodMatcher) Times(times uint) *getSecretTimes {
	m.matcher.Times = &times

	return &getSecretTimes{
		matcher: m,
	}
}

// Once specifies that the expectation will only match once.
func (m *getSecretMethodMatcher) Once() *getSecretTimes {
	return m.Times(1)
}

// Never specifies that the method has not been called. This is mainly useful for verification
// rather than mocking.
func (m *getSecretMethodMatcher) Never() *getSecretTimes {
	return m.Times(0)
}

// Return returns the specified results when the method is called.
func (t *getSecretTimes) Return(r0 *secretsmanager.GetSecretResult, r1 error) *getSecretAction {
	return &getSecretAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			Returns:       []any{r0, r1},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (t *getSecretTimes) Panic(arg any) *getSecretAction {
	return &getSecretAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (t *getSecretTimes) When(observe func(ctx context.Context, name string, opts ...func(*secretsmanager.GetSecretOptions)) (*secretsmanager.GetSecretResult, error)) *getSecretAction {
	return &getSecretAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			ObserveFn:     observe,
		},
	}
}

func (t *getSecretTimes) CreateMethodMatcher() *mocking.MethodMatcher {
	return &t.matcher.matcher
}

// Return returns the specified results when the method is called.
func (m *getSecretMethodMatcher) Return(r0 *secretsmanager.GetSecretResult, r1 error) *getSecretAction {
	return &getSecretAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			Returns:       []any{r0, r1},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (m *getSecretMethodMatcher) Panic(arg any) *getSecretAction {
	return &getSecretAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (m *getSecretMethodMatcher) When(observe func(ctx context.Context, name string, opts ...func(*secretsmanager.GetSecretOptions)) (*secretsmanager.GetSecretResult, error)) *getSecretAction {
	return &getSecretAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			ObserveFn:     observe,
		},
	}
}

type getSecretAction struct {
	expectation mocking.Expectation
}

func (a *getSecretAction) CreateExpectation() *mocking.Expectation {
	return &a.expectation
}
