// Code generated by Kelpie. DO NOT EDIT.
package sender

import (
	"github.com/adamconnelly/kelpie"
	"github.com/adamconnelly/kelpie/mocking"
)

type Mock struct {
	mocking.Mock
	instance instance
}

func NewMock() *Mock {
	mock := Mock{
		instance: instance{},
	}
	mock.instance.mock = &mock

	return &mock
}

type instance struct {
	mock *Mock
}

func (m *instance) SendMessage(title *string, message string) (r0 error) {
	expectation := m.mock.Call("SendMessage", title, message)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(title *string, message string) error)
			return observe(title, message)
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].(error)
		}
	}

	return
}

func (m *instance) SendMany(details map[string]string) (r0 error) {
	expectation := m.mock.Call("SendMany", details)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(details map[string]string) error)
			return observe(details)
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].(error)
		}
	}

	return
}

// Blocks the specified email address from being sent to.
func (m *instance) Block(_p0 string) (r0 error) {
	expectation := m.mock.Call("Block", _p0)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(_p0 string) error)
			return observe(_p0)
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].(error)
		}
	}

	return
}

func (m *Mock) Instance() *instance {
	return &m.instance
}

type sendMessageMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *sendMessageMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

func SendMessage[P0 *string | mocking.Matcher[*string], P1 string | mocking.Matcher[string]](title P0, message P1) *sendMessageMethodMatcher {
	result := sendMessageMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "SendMessage",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 2),
		},
	}

	if matcher, ok := any(title).(mocking.Matcher[*string]); ok {
		result.matcher.ArgumentMatchers[0] = matcher
	} else {
		result.matcher.ArgumentMatchers[0] = kelpie.ExactMatch(any(title).(*string))
	}

	if matcher, ok := any(message).(mocking.Matcher[string]); ok {
		result.matcher.ArgumentMatchers[1] = matcher
	} else {
		result.matcher.ArgumentMatchers[1] = kelpie.ExactMatch(any(message).(string))
	}

	return &result
}

type sendMessageTimes struct {
	matcher *sendMessageMethodMatcher
}

// Times allows you to restrict the number of times a particular expectation can be matched.
func (m *sendMessageMethodMatcher) Times(times uint) *sendMessageTimes {
	m.matcher.Times = &times

	return &sendMessageTimes{
		matcher: m,
	}
}

// Once specifies that the expectation will only match once.
func (m *sendMessageMethodMatcher) Once() *sendMessageTimes {
	return m.Times(1)
}

// Never specifies that the method has not been called. This is mainly useful for verification
// rather than mocking.
func (m *sendMessageMethodMatcher) Never() *sendMessageTimes {
	return m.Times(0)
}

// Return returns the specified results when the method is called.
func (t *sendMessageTimes) Return(r0 error) *sendMessageAction {
	return &sendMessageAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			Returns:       []any{r0},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (t *sendMessageTimes) Panic(arg any) *sendMessageAction {
	return &sendMessageAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (t *sendMessageTimes) When(observe func(title *string, message string) error) *sendMessageAction {
	return &sendMessageAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			ObserveFn:     observe,
		},
	}
}

func (t *sendMessageTimes) CreateMethodMatcher() *mocking.MethodMatcher {
	return &t.matcher.matcher
}

// Return returns the specified results when the method is called.
func (m *sendMessageMethodMatcher) Return(r0 error) *sendMessageAction {
	return &sendMessageAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			Returns:       []any{r0},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (m *sendMessageMethodMatcher) Panic(arg any) *sendMessageAction {
	return &sendMessageAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (m *sendMessageMethodMatcher) When(observe func(title *string, message string) error) *sendMessageAction {
	return &sendMessageAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			ObserveFn:     observe,
		},
	}
}

type sendMessageAction struct {
	expectation mocking.Expectation
}

func (a *sendMessageAction) CreateExpectation() *mocking.Expectation {
	return &a.expectation
}

type sendManyMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *sendManyMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

func SendMany[P0 map[string]string | mocking.Matcher[map[string]string]](details P0) *sendManyMethodMatcher {
	result := sendManyMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "SendMany",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 1),
		},
	}

	if matcher, ok := any(details).(mocking.Matcher[map[string]string]); ok {
		result.matcher.ArgumentMatchers[0] = matcher
	} else {
		result.matcher.ArgumentMatchers[0] = kelpie.ExactMatch(any(details).(map[string]string))
	}

	return &result
}

type sendManyTimes struct {
	matcher *sendManyMethodMatcher
}

// Times allows you to restrict the number of times a particular expectation can be matched.
func (m *sendManyMethodMatcher) Times(times uint) *sendManyTimes {
	m.matcher.Times = &times

	return &sendManyTimes{
		matcher: m,
	}
}

// Once specifies that the expectation will only match once.
func (m *sendManyMethodMatcher) Once() *sendManyTimes {
	return m.Times(1)
}

// Never specifies that the method has not been called. This is mainly useful for verification
// rather than mocking.
func (m *sendManyMethodMatcher) Never() *sendManyTimes {
	return m.Times(0)
}

// Return returns the specified results when the method is called.
func (t *sendManyTimes) Return(r0 error) *sendManyAction {
	return &sendManyAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			Returns:       []any{r0},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (t *sendManyTimes) Panic(arg any) *sendManyAction {
	return &sendManyAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (t *sendManyTimes) When(observe func(details map[string]string) error) *sendManyAction {
	return &sendManyAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			ObserveFn:     observe,
		},
	}
}

func (t *sendManyTimes) CreateMethodMatcher() *mocking.MethodMatcher {
	return &t.matcher.matcher
}

// Return returns the specified results when the method is called.
func (m *sendManyMethodMatcher) Return(r0 error) *sendManyAction {
	return &sendManyAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			Returns:       []any{r0},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (m *sendManyMethodMatcher) Panic(arg any) *sendManyAction {
	return &sendManyAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (m *sendManyMethodMatcher) When(observe func(details map[string]string) error) *sendManyAction {
	return &sendManyAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			ObserveFn:     observe,
		},
	}
}

type sendManyAction struct {
	expectation mocking.Expectation
}

func (a *sendManyAction) CreateExpectation() *mocking.Expectation {
	return &a.expectation
}

type blockMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *blockMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

// Blocks the specified email address from being sent to.
func Block[P0 string | mocking.Matcher[string]](_p0 P0) *blockMethodMatcher {
	result := blockMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "Block",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 1),
		},
	}

	if matcher, ok := any(_p0).(mocking.Matcher[string]); ok {
		result.matcher.ArgumentMatchers[0] = matcher
	} else {
		result.matcher.ArgumentMatchers[0] = kelpie.ExactMatch(any(_p0).(string))
	}

	return &result
}

type blockTimes struct {
	matcher *blockMethodMatcher
}

// Times allows you to restrict the number of times a particular expectation can be matched.
func (m *blockMethodMatcher) Times(times uint) *blockTimes {
	m.matcher.Times = &times

	return &blockTimes{
		matcher: m,
	}
}

// Once specifies that the expectation will only match once.
func (m *blockMethodMatcher) Once() *blockTimes {
	return m.Times(1)
}

// Never specifies that the method has not been called. This is mainly useful for verification
// rather than mocking.
func (m *blockMethodMatcher) Never() *blockTimes {
	return m.Times(0)
}

// Return returns the specified results when the method is called.
func (t *blockTimes) Return(r0 error) *blockAction {
	return &blockAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			Returns:       []any{r0},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (t *blockTimes) Panic(arg any) *blockAction {
	return &blockAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (t *blockTimes) When(observe func(_p0 string) error) *blockAction {
	return &blockAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			ObserveFn:     observe,
		},
	}
}

func (t *blockTimes) CreateMethodMatcher() *mocking.MethodMatcher {
	return &t.matcher.matcher
}

// Return returns the specified results when the method is called.
func (m *blockMethodMatcher) Return(r0 error) *blockAction {
	return &blockAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			Returns:       []any{r0},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (m *blockMethodMatcher) Panic(arg any) *blockAction {
	return &blockAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (m *blockMethodMatcher) When(observe func(_p0 string) error) *blockAction {
	return &blockAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			ObserveFn:     observe,
		},
	}
}

type blockAction struct {
	expectation mocking.Expectation
}

func (a *blockAction) CreateExpectation() *mocking.Expectation {
	return &a.expectation
}
