// Code generated by Kelpie. DO NOT EDIT.
package maths

import "github.com/adamconnelly/kelpie"

type Mock struct {
	expectations 	[]Expectation
	instance		Instance
}

func NewMock() *Mock {
	mock := Mock{
		instance: Instance{},
	}
	mock.instance.mock = &mock

	return &mock
}

type Instance struct {
	mock *Mock
}

func (m *Instance) Add(a int, b int) (r0 int) {
	for _, expectation := range m.mock.expectations {
		if expectation.method == "Add" {
			info := expectation.invocationDetails.(AddInvocationDetails)
			if info.a.IsMatch(a) && info.b.IsMatch(b) {
				if info.observe != nil {
					return info.observe(a, b)
				}

				if info.panicArg != nil {
					panic(info.panicArg)
				}

				return info.result0
			}
		}
	}

	return
}

func (m *Instance) ParseInt(input string) (r0 int, r1 error) {
	for _, expectation := range m.mock.expectations {
		if expectation.method == "ParseInt" {
			info := expectation.invocationDetails.(ParseIntInvocationDetails)
			if info.input.IsMatch(input) {
				if info.observe != nil {
					return info.observe(input)
				}

				if info.panicArg != nil {
					panic(info.panicArg)
				}

				return info.result0, info.result1
			}
		}
	}

	return
}

type Expectation struct {
	method            string
	invocationDetails interface{}
}

func (m *Mock) Instance() *Instance {
	return &m.instance
}

func (m *Mock) Reset() {
	m.expectations = nil
}

func (m *Mock) Setup(expectation Expectation) {
	m.expectations = append([]Expectation{expectation}, m.expectations...)
}


type AddInvocationDetails struct {
	a kelpie.Matcher[int]
	b kelpie.Matcher[int]
	result0 int
	panicArg any
	observe func(a int, b int) (int)
}

func Add[P0 int | kelpie.Matcher[int], P1 int | kelpie.Matcher[int]](a P0, b P1) AddInvocationDetails {
	result := AddInvocationDetails{}

	if matcher, ok := any(a).(kelpie.Matcher[int]); ok {
		result.a = matcher
	} else {
		result.a = kelpie.ExactMatch(any(a).(int))
	}

	if matcher, ok := any(b).(kelpie.Matcher[int]); ok {
		result.b = matcher
	} else {
		result.b = kelpie.ExactMatch(any(b).(int))
	}

	return result
}

func (a AddInvocationDetails) Return(r0 int) Expectation {
	a.result0 = r0

	return Expectation{
		method:            "Add",
		invocationDetails: a,
	}
}

func (a AddInvocationDetails) Panic(arg any) Expectation {
	a.panicArg = arg

	return Expectation{
		method:            "Add",
		invocationDetails: a,
	}
}

func (a AddInvocationDetails) When(callback func(a int, b int) (int)) Expectation {
	a.observe = callback

	return Expectation{
		method:            "Add",
		invocationDetails: a,
	}
}
type ParseIntInvocationDetails struct {
	input kelpie.Matcher[string]
	result0 int
	result1 error
	panicArg any
	observe func(input string) (int, error)
}

func ParseInt[P0 string | kelpie.Matcher[string]](input P0) ParseIntInvocationDetails {
	result := ParseIntInvocationDetails{}

	if matcher, ok := any(input).(kelpie.Matcher[string]); ok {
		result.input = matcher
	} else {
		result.input = kelpie.ExactMatch(any(input).(string))
	}

	return result
}

func (a ParseIntInvocationDetails) Return(r0 int, r1 error) Expectation {
	a.result0 = r0
	a.result1 = r1

	return Expectation{
		method:            "ParseInt",
		invocationDetails: a,
	}
}

func (a ParseIntInvocationDetails) Panic(arg any) Expectation {
	a.panicArg = arg

	return Expectation{
		method:            "ParseInt",
		invocationDetails: a,
	}
}

func (a ParseIntInvocationDetails) When(callback func(input string) (int, error)) Expectation {
	a.observe = callback

	return Expectation{
		method:            "ParseInt",
		invocationDetails: a,
	}
}
