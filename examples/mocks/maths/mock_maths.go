// Code generated by Kelpie. DO NOT EDIT.
package maths

import "github.com/adamconnelly/kelpie"

type Mock struct {
	kelpie.Mock
	instance Instance
}

func NewMock() *Mock {
	mock := Mock{
		instance: Instance{},
	}
	mock.instance.mock = &mock

	return &mock
}

type Instance struct {
	mock *Mock
}

func (m *Instance) Add(a int, b int) (r0 int) {
	expectation := m.mock.Call("Add", a, b)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(a int, b int) (int))
			return observe(a, b)
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		
		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].(int)
		}
		
	}

	return
}

func (m *Instance) ParseInt(input string) (r0 int, r1 error) {
	expectation := m.mock.Call("ParseInt", input)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(input string) (int, error))
			return observe(input)
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		
		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].(int)
		}
		
		if expectation.Returns[1] != nil {
			r1 = expectation.Returns[1].(error)
		}
		
	}

	return
}

func (m *Mock) Instance() *Instance {
	return &m.instance
}


type AddInvocationDetails struct {
	a kelpie.Matcher[int]
	b kelpie.Matcher[int]
}

func Add[P0 int | kelpie.Matcher[int], P1 int | kelpie.Matcher[int]](a P0, b P1) AddInvocationDetails {
	result := AddInvocationDetails{}

	if matcher, ok := any(a).(kelpie.Matcher[int]); ok {
		result.a = matcher
	} else {
		result.a = kelpie.ExactMatch(any(a).(int))
	}

	if matcher, ok := any(b).(kelpie.Matcher[int]); ok {
		result.b = matcher
	} else {
		result.b = kelpie.ExactMatch(any(b).(int))
	}

	return result
}

func (a AddInvocationDetails) Return(r0 int) *kelpie.Expectation {
	return &kelpie.Expectation{
		MethodName:       "Add",
		ArgumentMatchers: []kelpie.ArgumentMatcher{ a.a, a.b },
		Returns:          []any{ r0 },
	}
}

func (a AddInvocationDetails) Panic(arg any) *kelpie.Expectation {
	return &kelpie.Expectation{
		MethodName:       "Add",
		ArgumentMatchers: []kelpie.ArgumentMatcher{ a.a, a.b },
		PanicArg:         arg,
	}
}

func (a AddInvocationDetails) When(observe func(a int, b int) (int)) *kelpie.Expectation {
	return &kelpie.Expectation{
		MethodName:       "Add",
		ArgumentMatchers: []kelpie.ArgumentMatcher{ a.a, a.b },
		ObserveFn:        observe,
	}
}
type ParseIntInvocationDetails struct {
	input kelpie.Matcher[string]
}

func ParseInt[P0 string | kelpie.Matcher[string]](input P0) ParseIntInvocationDetails {
	result := ParseIntInvocationDetails{}

	if matcher, ok := any(input).(kelpie.Matcher[string]); ok {
		result.input = matcher
	} else {
		result.input = kelpie.ExactMatch(any(input).(string))
	}

	return result
}

func (a ParseIntInvocationDetails) Return(r0 int, r1 error) *kelpie.Expectation {
	return &kelpie.Expectation{
		MethodName:       "ParseInt",
		ArgumentMatchers: []kelpie.ArgumentMatcher{ a.input },
		Returns:          []any{ r0, r1 },
	}
}

func (a ParseIntInvocationDetails) Panic(arg any) *kelpie.Expectation {
	return &kelpie.Expectation{
		MethodName:       "ParseInt",
		ArgumentMatchers: []kelpie.ArgumentMatcher{ a.input },
		PanicArg:         arg,
	}
}

func (a ParseIntInvocationDetails) When(observe func(input string) (int, error)) *kelpie.Expectation {
	return &kelpie.Expectation{
		MethodName:       "ParseInt",
		ArgumentMatchers: []kelpie.ArgumentMatcher{ a.input },
		ObserveFn:        observe,
	}
}
