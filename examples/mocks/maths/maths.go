// Code generated by Kelpie. DO NOT EDIT.
package maths

import (
	"github.com/adamconnelly/kelpie"
	"github.com/adamconnelly/kelpie/mocking"
)

type Mock struct {
	mocking.Mock
	instance Instance
}

func NewMock() *Mock {
	mock := Mock{
		instance: Instance{},
	}
	mock.instance.mock = &mock

	return &mock
}

type Instance struct {
	mock *Mock
}

func (m *Instance) Add(a int, b int) (r0 int) {
	expectation := m.mock.Call("Add", a, b)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(a int, b int) int)
			return observe(a, b)
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].(int)
		}
	}

	return
}

func (m *Instance) ParseInt(input string) (r0 int, r1 error) {
	expectation := m.mock.Call("ParseInt", input)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(input string) (int, error))
			return observe(input)
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].(int)
		}

		if expectation.Returns[1] != nil {
			r1 = expectation.Returns[1].(error)
		}
	}

	return
}

func (m *Mock) Instance() *Instance {
	return &m.instance
}

type AddMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *AddMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

func Add[P0 int | mocking.Matcher[int], P1 int | mocking.Matcher[int]](a P0, b P1) *AddMethodMatcher {
	result := AddMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "Add",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 2),
		},
	}

	if matcher, ok := any(a).(mocking.Matcher[int]); ok {
		result.matcher.ArgumentMatchers[0] = matcher
	} else {
		result.matcher.ArgumentMatchers[0] = kelpie.ExactMatch(any(a).(int))
	}

	if matcher, ok := any(b).(mocking.Matcher[int]); ok {
		result.matcher.ArgumentMatchers[1] = matcher
	} else {
		result.matcher.ArgumentMatchers[1] = kelpie.ExactMatch(any(b).(int))
	}

	return &result
}

func (a *AddMethodMatcher) Return(r0 int) *AddAction {
	return &AddAction{
		expectation: mocking.Expectation{
			MethodMatcher: &a.matcher,
			Returns:       []any{r0},
		},
	}
}

func (a *AddMethodMatcher) Panic(arg any) *AddAction {
	return &AddAction{
		expectation: mocking.Expectation{
			MethodMatcher: &a.matcher,
			PanicArg:      arg,
		},
	}
}

func (a *AddMethodMatcher) When(observe func(a int, b int) int) *AddAction {
	return &AddAction{
		expectation: mocking.Expectation{
			MethodMatcher: &a.matcher,
			ObserveFn:     observe,
		},
	}
}

type AddAction struct {
	expectation mocking.Expectation
}

func (a *AddAction) CreateExpectation() *mocking.Expectation {
	return &a.expectation
}

func (a *AddAction) Times(times int) *AddTimes {
	a.expectation.MethodMatcher.Times = &times

	return &AddTimes{
		expectation: a.expectation,
	}
}

func (a *AddAction) Once() *AddTimes {
	times := 1
	a.expectation.MethodMatcher.Times = &times

	return &AddTimes{
		expectation: a.expectation,
	}
}

type AddTimes struct {
	expectation mocking.Expectation
}

func (t *AddTimes) CreateExpectation() *mocking.Expectation {
	return &t.expectation
}

type ParseIntMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *ParseIntMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

func ParseInt[P0 string | mocking.Matcher[string]](input P0) *ParseIntMethodMatcher {
	result := ParseIntMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "ParseInt",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 1),
		},
	}

	if matcher, ok := any(input).(mocking.Matcher[string]); ok {
		result.matcher.ArgumentMatchers[0] = matcher
	} else {
		result.matcher.ArgumentMatchers[0] = kelpie.ExactMatch(any(input).(string))
	}

	return &result
}

func (a *ParseIntMethodMatcher) Return(r0 int, r1 error) *ParseIntAction {
	return &ParseIntAction{
		expectation: mocking.Expectation{
			MethodMatcher: &a.matcher,
			Returns:       []any{r0, r1},
		},
	}
}

func (a *ParseIntMethodMatcher) Panic(arg any) *ParseIntAction {
	return &ParseIntAction{
		expectation: mocking.Expectation{
			MethodMatcher: &a.matcher,
			PanicArg:      arg,
		},
	}
}

func (a *ParseIntMethodMatcher) When(observe func(input string) (int, error)) *ParseIntAction {
	return &ParseIntAction{
		expectation: mocking.Expectation{
			MethodMatcher: &a.matcher,
			ObserveFn:     observe,
		},
	}
}

type ParseIntAction struct {
	expectation mocking.Expectation
}

func (a *ParseIntAction) CreateExpectation() *mocking.Expectation {
	return &a.expectation
}

func (a *ParseIntAction) Times(times int) *ParseIntTimes {
	a.expectation.MethodMatcher.Times = &times

	return &ParseIntTimes{
		expectation: a.expectation,
	}
}

func (a *ParseIntAction) Once() *ParseIntTimes {
	times := 1
	a.expectation.MethodMatcher.Times = &times

	return &ParseIntTimes{
		expectation: a.expectation,
	}
}

type ParseIntTimes struct {
	expectation mocking.Expectation
}

func (t *ParseIntTimes) CreateExpectation() *mocking.Expectation {
	return &t.expectation
}
