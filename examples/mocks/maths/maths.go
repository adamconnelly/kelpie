// Code generated by Kelpie. DO NOT EDIT.
package maths

import (
	"github.com/adamconnelly/kelpie"
	"github.com/adamconnelly/kelpie/mocking"
)

type Mock struct {
	mocking.Mock
	instance instance
}

func NewMock() *Mock {
	mock := Mock{
		instance: instance{},
	}
	mock.instance.mock = &mock

	return &mock
}

type instance struct {
	mock *Mock
}

// Add adds a and b together and returns the result.
func (m *instance) Add(a int, b int) (r0 int) {
	expectation := m.mock.Call("Add", a, b)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(a int, b int) int)
			return observe(a, b)
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].(int)
		}
	}

	return
}

// ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64)
// and returns the corresponding value i.
//
// The string may begin with a leading sign: "+" or "-".
//
// If the base argument is 0, the true base is implied by the string's prefix following
// the sign (if present): 2 for "0b", 8 for "0" or "0o", 16 for "0x", and 10 otherwise.
// Also, for argument base 0 only, underscore characters are permitted as defined by the
// Go syntax for integer literals.
//
// The bitSize argument specifies the integer type that the result must fit into. Bit
// sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize
// is below 0 or above 64, an error is returned.
//
// The errors that ParseInt returns have concrete type *NumError and include err.Num = s.
// If s is empty or contains invalid digits, err.Err = ErrSyntax and the returned value is
// 0; if the value corresponding to s cannot be represented by a signed integer of the given
// size, err.Err = ErrRange and the returned value is the maximum magnitude integer of the
// appropriate bitSize and sign.
func (m *instance) ParseInt(input string) (r0 int, r1 error) {
	expectation := m.mock.Call("ParseInt", input)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(input string) (int, error))
			return observe(input)
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].(int)
		}

		if expectation.Returns[1] != nil {
			r1 = expectation.Returns[1].(error)
		}
	}

	return
}

func (m *Mock) Instance() *instance {
	return &m.instance
}

type addMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *addMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

// Add adds a and b together and returns the result.
func Add[P0 int | mocking.Matcher[int], P1 int | mocking.Matcher[int]](a P0, b P1) *addMethodMatcher {
	result := addMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "Add",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 2),
		},
	}

	if matcher, ok := any(a).(mocking.Matcher[int]); ok {
		result.matcher.ArgumentMatchers[0] = matcher
	} else {
		result.matcher.ArgumentMatchers[0] = kelpie.ExactMatch(any(a).(int))
	}

	if matcher, ok := any(b).(mocking.Matcher[int]); ok {
		result.matcher.ArgumentMatchers[1] = matcher
	} else {
		result.matcher.ArgumentMatchers[1] = kelpie.ExactMatch(any(b).(int))
	}

	return &result
}

type addTimes struct {
	matcher *addMethodMatcher
}

// Times allows you to restrict the number of times a particular expectation can be matched.
func (m *addMethodMatcher) Times(times uint) *addTimes {
	m.matcher.Times = &times

	return &addTimes{
		matcher: m,
	}
}

// Once specifies that the expectation will only match once.
func (m *addMethodMatcher) Once() *addTimes {
	return m.Times(1)
}

// Never specifies that the method has not been called. This is mainly useful for verification
// rather than mocking.
func (m *addMethodMatcher) Never() *addTimes {
	return m.Times(0)
}

// Return returns the specified results when the method is called.
func (t *addTimes) Return(r0 int) *addAction {
	return &addAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			Returns:       []any{r0},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (t *addTimes) Panic(arg any) *addAction {
	return &addAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (t *addTimes) When(observe func(a int, b int) int) *addAction {
	return &addAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			ObserveFn:     observe,
		},
	}
}

func (t *addTimes) CreateMethodMatcher() *mocking.MethodMatcher {
	return &t.matcher.matcher
}

// Return returns the specified results when the method is called.
func (m *addMethodMatcher) Return(r0 int) *addAction {
	return &addAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			Returns:       []any{r0},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (m *addMethodMatcher) Panic(arg any) *addAction {
	return &addAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (m *addMethodMatcher) When(observe func(a int, b int) int) *addAction {
	return &addAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			ObserveFn:     observe,
		},
	}
}

type addAction struct {
	expectation mocking.Expectation
}

func (a *addAction) CreateExpectation() *mocking.Expectation {
	return &a.expectation
}

type parseIntMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *parseIntMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

// ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64)
// and returns the corresponding value i.
//
// The string may begin with a leading sign: "+" or "-".
//
// If the base argument is 0, the true base is implied by the string's prefix following
// the sign (if present): 2 for "0b", 8 for "0" or "0o", 16 for "0x", and 10 otherwise.
// Also, for argument base 0 only, underscore characters are permitted as defined by the
// Go syntax for integer literals.
//
// The bitSize argument specifies the integer type that the result must fit into. Bit
// sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize
// is below 0 or above 64, an error is returned.
//
// The errors that ParseInt returns have concrete type *NumError and include err.Num = s.
// If s is empty or contains invalid digits, err.Err = ErrSyntax and the returned value is
// 0; if the value corresponding to s cannot be represented by a signed integer of the given
// size, err.Err = ErrRange and the returned value is the maximum magnitude integer of the
// appropriate bitSize and sign.
func ParseInt[P0 string | mocking.Matcher[string]](input P0) *parseIntMethodMatcher {
	result := parseIntMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "ParseInt",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 1),
		},
	}

	if matcher, ok := any(input).(mocking.Matcher[string]); ok {
		result.matcher.ArgumentMatchers[0] = matcher
	} else {
		result.matcher.ArgumentMatchers[0] = kelpie.ExactMatch(any(input).(string))
	}

	return &result
}

type parseIntTimes struct {
	matcher *parseIntMethodMatcher
}

// Times allows you to restrict the number of times a particular expectation can be matched.
func (m *parseIntMethodMatcher) Times(times uint) *parseIntTimes {
	m.matcher.Times = &times

	return &parseIntTimes{
		matcher: m,
	}
}

// Once specifies that the expectation will only match once.
func (m *parseIntMethodMatcher) Once() *parseIntTimes {
	return m.Times(1)
}

// Never specifies that the method has not been called. This is mainly useful for verification
// rather than mocking.
func (m *parseIntMethodMatcher) Never() *parseIntTimes {
	return m.Times(0)
}

// Return returns the specified results when the method is called.
func (t *parseIntTimes) Return(r0 int, r1 error) *parseIntAction {
	return &parseIntAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			Returns:       []any{r0, r1},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (t *parseIntTimes) Panic(arg any) *parseIntAction {
	return &parseIntAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (t *parseIntTimes) When(observe func(input string) (int, error)) *parseIntAction {
	return &parseIntAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			ObserveFn:     observe,
		},
	}
}

func (t *parseIntTimes) CreateMethodMatcher() *mocking.MethodMatcher {
	return &t.matcher.matcher
}

// Return returns the specified results when the method is called.
func (m *parseIntMethodMatcher) Return(r0 int, r1 error) *parseIntAction {
	return &parseIntAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			Returns:       []any{r0, r1},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (m *parseIntMethodMatcher) Panic(arg any) *parseIntAction {
	return &parseIntAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (m *parseIntMethodMatcher) When(observe func(input string) (int, error)) *parseIntAction {
	return &parseIntAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			ObserveFn:     observe,
		},
	}
}

type parseIntAction struct {
	expectation mocking.Expectation
}

func (a *parseIntAction) CreateExpectation() *mocking.Expectation {
	return &a.expectation
}
