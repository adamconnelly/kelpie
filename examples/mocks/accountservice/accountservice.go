// Code generated by Kelpie. DO NOT EDIT.
package accountservice

import (
	"github.com/adamconnelly/kelpie"
	"github.com/adamconnelly/kelpie/mocking"
)

type Mock struct {
	mocking.Mock
	instance Instance
}

func NewMock() *Mock {
	mock := Mock{
		instance: Instance{},
	}
	mock.instance.mock = &mock

	return &mock
}

type Instance struct {
	mock *Mock
}

func (m *Instance) SendActivationEmail(emailAddress string) (r0 bool) {
	expectation := m.mock.Call("SendActivationEmail", emailAddress)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(emailAddress string) bool)
			return observe(emailAddress)
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].(bool)
		}
	}

	return
}

func (m *Instance) DisableAccount(id uint) {
	expectation := m.mock.Call("DisableAccount", id)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(id uint))
			observe(id)
			return
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}
	}

	return
}

func (m *Instance) DisabledAccountIDs() (r0 []uint) {
	expectation := m.mock.Call("DisabledAccountIDs")
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func() []uint)
			return observe()
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].([]uint)
		}
	}

	return
}

func (m *Mock) Instance() *Instance {
	return &m.instance
}

type SendActivationEmailMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *SendActivationEmailMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

func SendActivationEmail[P0 string | mocking.Matcher[string]](emailAddress P0) *SendActivationEmailMethodMatcher {
	result := SendActivationEmailMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "SendActivationEmail",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 1),
		},
	}

	if matcher, ok := any(emailAddress).(mocking.Matcher[string]); ok {
		result.matcher.ArgumentMatchers[0] = matcher
	} else {
		result.matcher.ArgumentMatchers[0] = kelpie.ExactMatch(any(emailAddress).(string))
	}

	return &result
}

type SendActivationEmailExpectation struct {
	expectation mocking.Expectation
}

func (e *SendActivationEmailExpectation) CreateExpectation() *mocking.Expectation {
	return &e.expectation
}

func (a *SendActivationEmailMethodMatcher) Return(r0 bool) *SendActivationEmailExpectation {
	return &SendActivationEmailExpectation{
		expectation: mocking.Expectation{
			MethodMatcher: &a.matcher,
			Returns:       []any{r0},
		},
	}
}

func (a *SendActivationEmailMethodMatcher) Panic(arg any) *SendActivationEmailExpectation {
	return &SendActivationEmailExpectation{
		expectation: mocking.Expectation{
			MethodMatcher: &a.matcher,
			PanicArg:      arg,
		},
	}
}

func (a *SendActivationEmailMethodMatcher) When(observe func(emailAddress string) bool) *SendActivationEmailExpectation {
	return &SendActivationEmailExpectation{
		expectation: mocking.Expectation{
			MethodMatcher: &a.matcher,
			ObserveFn:     observe,
		},
	}
}

type DisableAccountMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *DisableAccountMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

func DisableAccount[P0 uint | mocking.Matcher[uint]](id P0) *DisableAccountMethodMatcher {
	result := DisableAccountMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "DisableAccount",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 1),
		},
	}

	if matcher, ok := any(id).(mocking.Matcher[uint]); ok {
		result.matcher.ArgumentMatchers[0] = matcher
	} else {
		result.matcher.ArgumentMatchers[0] = kelpie.ExactMatch(any(id).(uint))
	}

	return &result
}

type DisableAccountExpectation struct {
	expectation mocking.Expectation
}

func (e *DisableAccountExpectation) CreateExpectation() *mocking.Expectation {
	return &e.expectation
}

func (a *DisableAccountMethodMatcher) Panic(arg any) *DisableAccountExpectation {
	return &DisableAccountExpectation{
		expectation: mocking.Expectation{
			MethodMatcher: &a.matcher,
			PanicArg:      arg,
		},
	}
}

func (a *DisableAccountMethodMatcher) When(observe func(id uint)) *DisableAccountExpectation {
	return &DisableAccountExpectation{
		expectation: mocking.Expectation{
			MethodMatcher: &a.matcher,
			ObserveFn:     observe,
		},
	}
}

type DisabledAccountIDsMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *DisabledAccountIDsMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

func DisabledAccountIDs() *DisabledAccountIDsMethodMatcher {
	result := DisabledAccountIDsMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "DisabledAccountIDs",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 0),
		},
	}

	return &result
}

type DisabledAccountIDsExpectation struct {
	expectation mocking.Expectation
}

func (e *DisabledAccountIDsExpectation) CreateExpectation() *mocking.Expectation {
	return &e.expectation
}

func (a *DisabledAccountIDsMethodMatcher) Return(r0 []uint) *DisabledAccountIDsExpectation {
	return &DisabledAccountIDsExpectation{
		expectation: mocking.Expectation{
			MethodMatcher: &a.matcher,
			Returns:       []any{r0},
		},
	}
}

func (a *DisabledAccountIDsMethodMatcher) Panic(arg any) *DisabledAccountIDsExpectation {
	return &DisabledAccountIDsExpectation{
		expectation: mocking.Expectation{
			MethodMatcher: &a.matcher,
			PanicArg:      arg,
		},
	}
}

func (a *DisabledAccountIDsMethodMatcher) When(observe func() []uint) *DisabledAccountIDsExpectation {
	return &DisabledAccountIDsExpectation{
		expectation: mocking.Expectation{
			MethodMatcher: &a.matcher,
			ObserveFn:     observe,
		},
	}
}
