// Code generated by Kelpie. DO NOT EDIT.
package accountservice

import (
	"github.com/adamconnelly/kelpie"
	"github.com/adamconnelly/kelpie/mocking"
)

type Mock struct {
	mocking.Mock
	instance instance
}

func NewMock() *Mock {
	mock := Mock{
		instance: instance{},
	}
	mock.instance.mock = &mock

	return &mock
}

type instance struct {
	mock *Mock
}

func (m *instance) SendActivationEmail(emailAddress string) (r0 bool) {
	expectation := m.mock.Call("SendActivationEmail", emailAddress)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(emailAddress string) bool)
			return observe(emailAddress)
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].(bool)
		}
	}

	return
}

func (m *instance) DisableAccount(id uint) {
	expectation := m.mock.Call("DisableAccount", id)
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func(id uint))
			observe(id)
			return
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}
	}

	return
}

func (m *instance) DisabledAccountIDs() (r0 []uint) {
	expectation := m.mock.Call("DisabledAccountIDs")
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func() []uint)
			return observe()
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].([]uint)
		}
	}

	return
}

func (m *instance) DisableReasons() (r0 map[uint]string) {
	expectation := m.mock.Call("DisableReasons")
	if expectation != nil {
		if expectation.ObserveFn != nil {
			observe := expectation.ObserveFn.(func() map[uint]string)
			return observe()
		}

		if expectation.PanicArg != nil {
			panic(expectation.PanicArg)
		}

		if expectation.Returns[0] != nil {
			r0 = expectation.Returns[0].(map[uint]string)
		}
	}

	return
}

func (m *Mock) Instance() *instance {
	return &m.instance
}

type sendActivationEmailMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *sendActivationEmailMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

func SendActivationEmail[P0 string | mocking.Matcher[string]](emailAddress P0) *sendActivationEmailMethodMatcher {
	result := sendActivationEmailMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "SendActivationEmail",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 1),
		},
	}

	if matcher, ok := any(emailAddress).(mocking.Matcher[string]); ok {
		result.matcher.ArgumentMatchers[0] = matcher
	} else {
		result.matcher.ArgumentMatchers[0] = kelpie.ExactMatch(any(emailAddress).(string))
	}

	return &result
}

type sendActivationEmailTimes struct {
	matcher *sendActivationEmailMethodMatcher
}

// Times allows you to restrict the number of times a particular expectation can be matched.
func (m *sendActivationEmailMethodMatcher) Times(times uint) *sendActivationEmailTimes {
	m.matcher.Times = &times

	return &sendActivationEmailTimes{
		matcher: m,
	}
}

// Once specifies that the expectation will only match once.
func (m *sendActivationEmailMethodMatcher) Once() *sendActivationEmailTimes {
	return m.Times(1)
}

// Never specifies that the method has not been called. This is mainly useful for verification
// rather than mocking.
func (m *sendActivationEmailMethodMatcher) Never() *sendActivationEmailTimes {
	return m.Times(0)
}

// Return returns the specified results when the method is called.
func (t *sendActivationEmailTimes) Return(r0 bool) *sendActivationEmailAction {
	return &sendActivationEmailAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			Returns:       []any{r0},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (t *sendActivationEmailTimes) Panic(arg any) *sendActivationEmailAction {
	return &sendActivationEmailAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (t *sendActivationEmailTimes) When(observe func(emailAddress string) bool) *sendActivationEmailAction {
	return &sendActivationEmailAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			ObserveFn:     observe,
		},
	}
}

func (t *sendActivationEmailTimes) CreateMethodMatcher() *mocking.MethodMatcher {
	return &t.matcher.matcher
}

// Return returns the specified results when the method is called.
func (m *sendActivationEmailMethodMatcher) Return(r0 bool) *sendActivationEmailAction {
	return &sendActivationEmailAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			Returns:       []any{r0},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (m *sendActivationEmailMethodMatcher) Panic(arg any) *sendActivationEmailAction {
	return &sendActivationEmailAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (m *sendActivationEmailMethodMatcher) When(observe func(emailAddress string) bool) *sendActivationEmailAction {
	return &sendActivationEmailAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			ObserveFn:     observe,
		},
	}
}

type sendActivationEmailAction struct {
	expectation mocking.Expectation
}

func (a *sendActivationEmailAction) CreateExpectation() *mocking.Expectation {
	return &a.expectation
}

type disableAccountMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *disableAccountMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

func DisableAccount[P0 uint | mocking.Matcher[uint]](id P0) *disableAccountMethodMatcher {
	result := disableAccountMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "DisableAccount",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 1),
		},
	}

	if matcher, ok := any(id).(mocking.Matcher[uint]); ok {
		result.matcher.ArgumentMatchers[0] = matcher
	} else {
		result.matcher.ArgumentMatchers[0] = kelpie.ExactMatch(any(id).(uint))
	}

	return &result
}

type disableAccountTimes struct {
	matcher *disableAccountMethodMatcher
}

// Times allows you to restrict the number of times a particular expectation can be matched.
func (m *disableAccountMethodMatcher) Times(times uint) *disableAccountTimes {
	m.matcher.Times = &times

	return &disableAccountTimes{
		matcher: m,
	}
}

// Once specifies that the expectation will only match once.
func (m *disableAccountMethodMatcher) Once() *disableAccountTimes {
	return m.Times(1)
}

// Never specifies that the method has not been called. This is mainly useful for verification
// rather than mocking.
func (m *disableAccountMethodMatcher) Never() *disableAccountTimes {
	return m.Times(0)
}

// Panic panics using the specified argument when the method is called.
func (t *disableAccountTimes) Panic(arg any) *disableAccountAction {
	return &disableAccountAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (t *disableAccountTimes) When(observe func(id uint)) *disableAccountAction {
	return &disableAccountAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			ObserveFn:     observe,
		},
	}
}

func (t *disableAccountTimes) CreateMethodMatcher() *mocking.MethodMatcher {
	return &t.matcher.matcher
}

// Panic panics using the specified argument when the method is called.
func (m *disableAccountMethodMatcher) Panic(arg any) *disableAccountAction {
	return &disableAccountAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (m *disableAccountMethodMatcher) When(observe func(id uint)) *disableAccountAction {
	return &disableAccountAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			ObserveFn:     observe,
		},
	}
}

type disableAccountAction struct {
	expectation mocking.Expectation
}

func (a *disableAccountAction) CreateExpectation() *mocking.Expectation {
	return &a.expectation
}

type disabledAccountIDsMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *disabledAccountIDsMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

func DisabledAccountIDs() *disabledAccountIDsMethodMatcher {
	result := disabledAccountIDsMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "DisabledAccountIDs",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 0),
		},
	}

	return &result
}

type disabledAccountIDsTimes struct {
	matcher *disabledAccountIDsMethodMatcher
}

// Times allows you to restrict the number of times a particular expectation can be matched.
func (m *disabledAccountIDsMethodMatcher) Times(times uint) *disabledAccountIDsTimes {
	m.matcher.Times = &times

	return &disabledAccountIDsTimes{
		matcher: m,
	}
}

// Once specifies that the expectation will only match once.
func (m *disabledAccountIDsMethodMatcher) Once() *disabledAccountIDsTimes {
	return m.Times(1)
}

// Never specifies that the method has not been called. This is mainly useful for verification
// rather than mocking.
func (m *disabledAccountIDsMethodMatcher) Never() *disabledAccountIDsTimes {
	return m.Times(0)
}

// Return returns the specified results when the method is called.
func (t *disabledAccountIDsTimes) Return(r0 []uint) *disabledAccountIDsAction {
	return &disabledAccountIDsAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			Returns:       []any{r0},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (t *disabledAccountIDsTimes) Panic(arg any) *disabledAccountIDsAction {
	return &disabledAccountIDsAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (t *disabledAccountIDsTimes) When(observe func() []uint) *disabledAccountIDsAction {
	return &disabledAccountIDsAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			ObserveFn:     observe,
		},
	}
}

func (t *disabledAccountIDsTimes) CreateMethodMatcher() *mocking.MethodMatcher {
	return &t.matcher.matcher
}

// Return returns the specified results when the method is called.
func (m *disabledAccountIDsMethodMatcher) Return(r0 []uint) *disabledAccountIDsAction {
	return &disabledAccountIDsAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			Returns:       []any{r0},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (m *disabledAccountIDsMethodMatcher) Panic(arg any) *disabledAccountIDsAction {
	return &disabledAccountIDsAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (m *disabledAccountIDsMethodMatcher) When(observe func() []uint) *disabledAccountIDsAction {
	return &disabledAccountIDsAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			ObserveFn:     observe,
		},
	}
}

type disabledAccountIDsAction struct {
	expectation mocking.Expectation
}

func (a *disabledAccountIDsAction) CreateExpectation() *mocking.Expectation {
	return &a.expectation
}

type disableReasonsMethodMatcher struct {
	matcher mocking.MethodMatcher
}

func (m *disableReasonsMethodMatcher) CreateMethodMatcher() *mocking.MethodMatcher {
	return &m.matcher
}

func DisableReasons() *disableReasonsMethodMatcher {
	result := disableReasonsMethodMatcher{
		matcher: mocking.MethodMatcher{
			MethodName:       "DisableReasons",
			ArgumentMatchers: make([]mocking.ArgumentMatcher, 0),
		},
	}

	return &result
}

type disableReasonsTimes struct {
	matcher *disableReasonsMethodMatcher
}

// Times allows you to restrict the number of times a particular expectation can be matched.
func (m *disableReasonsMethodMatcher) Times(times uint) *disableReasonsTimes {
	m.matcher.Times = &times

	return &disableReasonsTimes{
		matcher: m,
	}
}

// Once specifies that the expectation will only match once.
func (m *disableReasonsMethodMatcher) Once() *disableReasonsTimes {
	return m.Times(1)
}

// Never specifies that the method has not been called. This is mainly useful for verification
// rather than mocking.
func (m *disableReasonsMethodMatcher) Never() *disableReasonsTimes {
	return m.Times(0)
}

// Return returns the specified results when the method is called.
func (t *disableReasonsTimes) Return(r0 map[uint]string) *disableReasonsAction {
	return &disableReasonsAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			Returns:       []any{r0},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (t *disableReasonsTimes) Panic(arg any) *disableReasonsAction {
	return &disableReasonsAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (t *disableReasonsTimes) When(observe func() map[uint]string) *disableReasonsAction {
	return &disableReasonsAction{
		expectation: mocking.Expectation{
			MethodMatcher: &t.matcher.matcher,
			ObserveFn:     observe,
		},
	}
}

func (t *disableReasonsTimes) CreateMethodMatcher() *mocking.MethodMatcher {
	return &t.matcher.matcher
}

// Return returns the specified results when the method is called.
func (m *disableReasonsMethodMatcher) Return(r0 map[uint]string) *disableReasonsAction {
	return &disableReasonsAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			Returns:       []any{r0},
		},
	}
}

// Panic panics using the specified argument when the method is called.
func (m *disableReasonsMethodMatcher) Panic(arg any) *disableReasonsAction {
	return &disableReasonsAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			PanicArg:      arg,
		},
	}
}

// When calls the specified observe callback when the method is called.
func (m *disableReasonsMethodMatcher) When(observe func() map[uint]string) *disableReasonsAction {
	return &disableReasonsAction{
		expectation: mocking.Expectation{
			MethodMatcher: &m.matcher,
			ObserveFn:     observe,
		},
	}
}

type disableReasonsAction struct {
	expectation mocking.Expectation
}

func (a *disableReasonsAction) CreateExpectation() *mocking.Expectation {
	return &a.expectation
}
